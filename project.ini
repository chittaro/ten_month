# Throughout this configuration file, wherever an executable is named, it's
# assumed that it can be generated by going into the directory where that
# executable is located and running `make <executable-name>`. Additionally,
# every `Makefile` should have a `clean` target which removes that executable
# and any intermediate files.
#
# The autograder will rebuild all of these executables when you deploy the
# project.
#
# These executables include:
#     * The staff solution.
#     * The test-suite solution.
#     * The buggy solutions.
#     * The judges.
#     * The get_flags_command program.
#
# Executables must never call `exit(1)`. To return a status, they must exit
# with either 0 or 2. Otherwise, the autograder will not detect unusual
# situations, such as the executable segfaulting.

# General information about the project.
[project-info]
# A five-character ID for the project, with a three-character semester code and
# a two-character project code. It should be one-indexed; don't use P0. This
# should all be capitalized. The semester is inferred from the first three
# characters.
project-id = S23P2A

# The project description, such as that given in the project spec.
project-description = Project 2 Part A - Stock Market Simulation

# The project identifier, will make it easier to find public repositories in the future.
# Use "none" (without quotes) if not used.
identifier = 0E04A31E0D60C01986ACB20081C9D8722A1899B6

# Whether to give the students hints based on meeting certain criteraia.
# Set this equal to the word 'none' (without quotes) to disable hints
hints-file = hints.txt

# The closing date, in YYYY-MM-DD format. The project will close at midnight at
# the end of this day.
closing-date = 2023-05-22

# The number of submissions that are allowed per day.
daily-submissions = 3

# The name of the executable we expect the student's `Makefile` to generate.
submission-exe = market

# The name of the solution directory, relative to the project directory. This
# has the source code for the staff solution, which can be compiled with a
# number of conditional flags to produce variations on the solution.
solution-dir = ag/solution

# The executable name.
staff-solution-exe = market

# The directory with the judges in them. These are used to check if a student's
# solution was identical, and, if not, display relevant output. They must
# return 0 if the student solution was correct and 2 if not.
#
# A judge is passed `<expected_file> <student_file> <input_file>` on the command
# line. For historical reasons, they can't be in a different order.
#
# If the judge returns 0 and prints output, the first line of that output is
# assumed to be a ratio between zero and one denoting the proportion of points
# earned by the student. So output of "0.75" on the first line will cause the
# student to get 75% of the points for that test.
judge-dir = ag/judges

# The list of the available judges in the judge directory. For most projects,
# `line_judge` is sufficient (the exception being the travelling salesman
# project).
#
# A better judge to use is the 'edit_distance_judge', which gives them the
# entire line if they are 'close enough' to the correct line.  It reverts to
# partial feedback if they are too far off, or the line is excessively long.
#
# The first part of the colon-delimited word is the judge executable. The
# second part is a regex that any test cases which it judges match. If a judge
# is used for everything, then the catch-all regex `^` can be used.
#
# judge-exes = line_judge:^ABC-  mst_judge:^MST-  etc...
judge-exes = edit_distance_judge:^

# The total number of points for the project. If this is a homework assignment,
# you would probably reduce this.
total-points = 60

# This tells the autograder how to pass the input file to the solution. If this
# is set to 0, the input filename is passed as the first unnamed argument on the
# command line. If it is set to 1, the input file is piped into standard input.
#
# For example, with 0, the solution is invoked like this:
#
#     ./solution test-input-file.txt --other --flags
#
# With 1, the solution is invoked like this:
#
#     ./solution <test-input-file.txt --other --flags
#
# Prefer to pipe into standard input when possible.
tests-to-stdin = 1

# The dictionary of acceptable cerr output strings to show students.
# Comma separated, whitespace will be stripped on both sides.
# Checked for equality case insensitive.
valid-cerr-output = ./market: error while loading shared libraries: libgcc_s.so.1: cannot open shared object file: Operation not permitted, Error: Unknown command line option, Error: Decreasing timestamp, Error: Invalid trader ID, Error: Invalid stock ID, Error: Invalid price, Error: Invalid quantity

# Configuration for the jail. For regular projects, you probably won't need to
# modify this, but you might for homeworks.
[jail-info]
# The time (in seconds) to wait before killing the student's program.
time-limit = 35

# Disk usage limit (in bytes). This is for the output generated by the
# student's program. You can probably leave this alone, unless the student
# needs to generate even more output than this.
disk-limit = 17000000

# Memory usage limit (in megabytes).
memory-limit = 2048

# Copy any student files to the compilation directory. Leave empty if you want
# copy over every file. This is mostly relevant for the homeworks.
#
# student-files = homework.cpp
student-files =

# These are files of our own that should be copied to the compilation
# directory. This preserves directory structure; if you pass `foo/bar/baz.txt`,
# it will be copied to `foo/bar/baz.txt` in the root of the submission
# directory (creating any intermediate directories if they don't exist).
#
# grader-files = Makefile main.cpp homework.h
grader-files =

# For EECS 281, we prohibit the libraries given here by default. You should
# not remove any of them, but only add new ones.
#
# To get the file path for a library, put "#include <algorithm>" in a .cpp file
# and compile it with `g++ -E`. Then grep for "c++" to get lines with paths like
# this one. (You'll need to do this on the autograder server, since your local
# machine probably doesn't have the same set of libraries.)
#
# The defaults are to prohibit regex and smart pointers. You should probably
# append to these rather than replace them.
prohibited-libraries = include/c++/4.7.0/regex
                       include/c++/4.7.0/memory
                       include/c++/4.7.0/bits/unique_ptr.h
                       include/c++/4.7.0/bits/shared_ptr.h
                       include/c++/4.8.2/regex
                       include/c++/4.8.2/memory
                       include/c++/4.8.2/bits/unique_ptr.h
                       include/c++/4.8.2/bits/shared_ptr.h
                       include/c++/5.1.0/regex
                       include/c++/5.1.0/memory
                       include/c++/5.1.0/bits/unique_ptr.h
                       include/c++/5.1.0/bits/shared_ptr.h
                       include/c++/6.2.0/regex
                       include/c++/6.2.0/memory
                       include/c++/6.2.0/bits/unique_ptr.h
                       include/c++/6.2.0/bits/shared_ptr.h

# Integration tests are the usual test cases. An integration test has an input
# file and some number of command line flags. Then it is compared to the
# correct output file by using a judge, probably a line-by-line comparison.
[integration-info]
# The directory relative to the project root in which all of the test cases are
# located.
test-dir = ag/tests

# If any tests start with this prefix, it means that they should pass if the
# return status is 1, rather than giving some specific output. If no tests start
# with this prefix, then no tests will be graded in this way. The judge is
# ignored for these test cases.
invalid-test-prefix = INV

# The number of points to award for the test cases. These are divided up evenly
# among the test cases.
points = 50

# The number of points to award for not leaking memory. This makes up part of
# the `points` variable above; that is, 10/80 points are derived from
# memory-leak checking. Shouldn't be more than `points`. Set to zero or omit if
# you don't want to deduct points in this way (because you don't want
# leak-checking points or because you want to use `memory-leak-percent`).
memory-leak-points = 5

# The percentage of the total score to deduct if the student had memory leaks
# (as opposed to a set number of points as in `memory-leak-points`). Set to
# zero or omit if you don't want to deduct points in this way.
memory-leak-percent = 0

# It's expensive to valgrind every test case, so instead check only these
# cases. If any of these leak memory or produce incorrect output, no points are
# awarded.
leak-check-cases = stimv

# The scoring scale to use. You shouldn't change this without good reason.
#
# The part after the colon is the the fraction of full points they would get.
# The first part is the range of ratios to produce that score. (So a ratio of
# 1.5 means they exceeded the benchmark of 50%, and would get 95% on that test
# case.)
#
# The ranges are exclusive on the left side and inclusive on the right side.
# If the score doesn't fall into one of these ranges, the student gets a zero.
runtime-scoring = 0.00-1.00:1.00  1.00-1.10:0.90  1.10-1.50:0.75 1.50-2.00:0.50  2.00-3.00:0.40  3.00-4.00:0.30  4.00-5.00:.20  5.00-10.00:0.10
memory-scoring  = 0.00-1.00:1.00  1.00-1.10:0.90  1.10-1.50:0.75 1.50-2.00:0.50  2.00-3.00:0.40  3.00-4.00:0.30  4.00-5.00:.20  5.00-10.00:0.10

# A list of all the integration tests for the judge named `line_judge`, listed
# in `project-info`.
#
# The key (the thing before the equals sign) is the codename of a test, to be
# shown on the autograder webpage and so on. The first word in the value is the
# input file name, which must be found in `test-dir` specified in
# `integration-info`. Any remaining words are command-line flags.
[integration-tests]
INV-1   = INV-1.txt
INV-2   = INV-2.txt
INV-3   = INV-3.txt
INV-4   = INV-4.txt
INV-5   = INV-5.txt
INV-6   = INV-6.txt

sp      = sp.txt
spv     = sp.txt      -v
spt     = sp.txt      -t
spm     = sp.txt      -m
st      = st.txt
stm     = st.txt      --median
stv     = st.txt      --verbose
sti     = st.txt      --trader_info
stimv   = st.txt      --trader_info -m -v

PS2m    = Ps-02.txt   -m
PS2t    = Ps-02.txt   -t
PS2v    = Ps-02.txt   -v
PS2i    = Ps-02.txt   -i

# Checks for overflow on median with max integer; kinda tricky
# Prevents cool solution of a templated RunningMedian class,
# unless they store everything as a long int, or break the template.
#INT     = INT.txt     -v -m -i -t
1N1Limt = L-01.txt    -m -i --time_travelers
1N2LA   = L-02.txt    -v -m -i --time_travelers
HT      = HT.txt      -v
NOT     = NOTs-01.txt -v -m -i --time_travelers
RLS     = RLS.txt

M1A     = M-01.txt    -i -v -m -t
K2A     = K-02.txt    --time_travelers -v -m -i
K1t     = K-01.txt    --time_travelers
K1m     = K-01.txt    -m
K1A     = K-01.txt    --time_travelers -v -m -i
F7v     = F-07.txt    -v
F2A     = F-02.txt    -v -m --trader_info -t
F1A     = F-01.txt    -v -m -i -t
F9V     = F-09.txt    --verbose

S4v     = S-04.txt    -v
S4t     = S-04.txt    --time_travelers
S4m     = S-04.txt    -m
S4i     = S-04.txt    --trader_info
S4A     = S-04.txt     --time_travelers -v -m -i
S5A-GAP = S-05.txt    -v -m -i --time_travelers
S7v     = S-07.txt    -v
S7t     = S-07.txt    -t
S7m     = S-07.txt    -m
S7i     = S-07.txt    -i
S9v     = S-09.txt    -v
S9t     = S-09.txt    -t
S9m     = S-09.txt    -m
S9i     = S-09.txt    -i

Pm1imt  = Pm-01.txt   -m -i -t
Pm2imt  = Pm-02.txt   -m -i --time_travelers
Pm3imt  = Pm-03.txt   -m -i -t
Pm6i    = Pm-06.txt   -i
Pm6m    = Pm-06.txt   -m
Pm6t    = Pm-06.txt   -t
Pm6v    = Pm-06.txt   -v
Pm6A    = Pm-06.txt   -m -i -t -v

# Configuration for the student-submitted test suite. If the project has no
# test suite (for example, if it's a homework), then omit this section.
[suite-info]
# The number of points that the test suite is worth.
points = 10

# The maximum number of tests which the user is allowed to submit.
max-student-test-files = 15

# This is a script which parses the name of a test on the command line (like
# "test-1-c-ABC.txt") and echos out the command line flags for that test case
# (like "-c ABC"). It's assumed that the test itself is passed the usual way, as
# per `tests-to-stdin`. This script should be generate-able with `make`, and
# must run on the autograder (e.g. <= Python 2.6, if you do that.) . If the
# filename is invalid, it should return 2. It should be in `solution-dir`.
flags-command = get-test-flags

# Up to and including this number of caught bugs, the student gets no points.
# Then it's a linear scale up to `bugs-for-full-points` below.
min-bugs-for-points = 5

# The number of bugs needed to get full points on the test suite.
bugs-for-full-points = 15

# The number of bugs needed to get an extra submit/day.
bugs-for-extra-submit = 12

# The names of the buggy executables. It is assumed that we can go to the
# solution directory and generate these with `make bug1`, etc.
#
# If the list of bugs is long, keep in mind that it's valid syntax to have
# linebreaks in an .ini file.
#
# WARNING: For compatibility reasons with the old grading script, these /must/
# be named bugX, where X is a number, or they won't be detected.
buggy-solutions = bug1 bug2 bug3 bug4 bug5 bug6 bug7 bug8 bug9 bug10 bug11
                  bug12 bug13 bug14 bug15 bug16

# The name of the executable we use to test if a student's case caught a buggy
# solution. This must generate the correct solution (for example, when running
# `make <test-suite-exe>` in the solution directory). It must rigidly check
# input validity, and must ensure that the student test cases are not too
# large. If there is any invalid input, this program should `exit(2)`.
test-suite-exe = correct
